{"ast":null,"code":"import _slicedToArray from \"C:/Users/shubh/OneDrive/Desktop/radio with backend/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\n// creates a matcher function\nexport default function makeMatcher() {\n  var makeRegexpFn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : pathToRegexp;\n  var cache = {};\n\n  // obtains a cached regexp version of the pattern\n  var getRegexp = function getRegexp(pattern) {\n    return cache[pattern] || (cache[pattern] = makeRegexpFn(pattern));\n  };\n  return function (pattern, path) {\n    var _getRegexp = getRegexp(pattern || \"\"),\n      regexp = _getRegexp.regexp,\n      keys = _getRegexp.keys;\n    var out = regexp.exec(path);\n    if (!out) return [false, null];\n\n    // formats an object with matched params\n    var params = keys.reduce(function (params, key, i) {\n      params[key.name] = out[i + 1];\n      return params;\n    }, {});\n    return [true, params];\n  };\n}\n\n// escapes a regexp string (borrowed from path-to-regexp sources)\n// https://github.com/pillarjs/path-to-regexp/blob/v3.0.0/index.js#L202\nvar escapeRx = function escapeRx(str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n};\n\n// returns a segment representation in RegExp based on flags\n// adapted and simplified version from path-to-regexp sources\nvar rxForSegment = function rxForSegment(repeat, optional, prefix) {\n  var capture = repeat ? \"((?:[^\\\\/]+?)(?:\\\\/(?:[^\\\\/]+?))*)\" : \"([^\\\\/]+?)\";\n  if (optional && prefix) capture = \"(?:\\\\/\" + capture + \")\";\n  return capture + (optional ? \"?\" : \"\");\n};\nvar pathToRegexp = function pathToRegexp(pattern) {\n  var groupRx = /:([A-Za-z0-9_]+)([?+*]?)/g;\n  var match = null,\n    lastIndex = 0,\n    keys = [],\n    result = \"\";\n  while ((match = groupRx.exec(pattern)) !== null) {\n    var _match = match,\n      _match2 = _slicedToArray(_match, 3),\n      _ = _match2[0],\n      segment = _match2[1],\n      mod = _match2[2];\n\n    // :foo  [1]      (  )\n    // :foo? [0 - 1]  ( o)\n    // :foo+ [1 - ∞]  (r )\n    // :foo* [0 - ∞]  (ro)\n    var repeat = mod === \"+\" || mod === \"*\";\n    var optional = mod === \"?\" || mod === \"*\";\n    var prefix = optional && pattern[match.index - 1] === \"/\" ? 1 : 0;\n    var prev = pattern.substring(lastIndex, match.index - prefix);\n    keys.push({\n      name: segment\n    });\n    lastIndex = groupRx.lastIndex;\n    result += escapeRx(prev) + rxForSegment(repeat, optional, prefix);\n  }\n  result += escapeRx(pattern.substring(lastIndex));\n  return {\n    keys: keys,\n    regexp: new RegExp(\"^\" + result + \"(?:\\\\/)?$\", \"i\")\n  };\n};","map":{"version":3,"names":["makeMatcher","makeRegexpFn","arguments","length","undefined","pathToRegexp","cache","getRegexp","pattern","path","_getRegexp","regexp","keys","out","exec","params","reduce","key","i","name","escapeRx","str","replace","rxForSegment","repeat","optional","prefix","capture","groupRx","match","lastIndex","result","_match","_match2","_slicedToArray","_","segment","mod","index","prev","substring","push","RegExp"],"sources":["C:/Users/shubh/OneDrive/Desktop/radio with backend/frontend/node_modules/wouter/matcher.js"],"sourcesContent":["// creates a matcher function\nexport default function makeMatcher(makeRegexpFn = pathToRegexp) {\n  let cache = {};\n\n  // obtains a cached regexp version of the pattern\n  const getRegexp = (pattern) =>\n    cache[pattern] || (cache[pattern] = makeRegexpFn(pattern));\n\n  return (pattern, path) => {\n    const { regexp, keys } = getRegexp(pattern || \"\");\n    const out = regexp.exec(path);\n\n    if (!out) return [false, null];\n\n    // formats an object with matched params\n    const params = keys.reduce((params, key, i) => {\n      params[key.name] = out[i + 1];\n      return params;\n    }, {});\n\n    return [true, params];\n  };\n}\n\n// escapes a regexp string (borrowed from path-to-regexp sources)\n// https://github.com/pillarjs/path-to-regexp/blob/v3.0.0/index.js#L202\nconst escapeRx = (str) => str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n\n// returns a segment representation in RegExp based on flags\n// adapted and simplified version from path-to-regexp sources\nconst rxForSegment = (repeat, optional, prefix) => {\n  let capture = repeat ? \"((?:[^\\\\/]+?)(?:\\\\/(?:[^\\\\/]+?))*)\" : \"([^\\\\/]+?)\";\n  if (optional && prefix) capture = \"(?:\\\\/\" + capture + \")\";\n  return capture + (optional ? \"?\" : \"\");\n};\n\nconst pathToRegexp = (pattern) => {\n  const groupRx = /:([A-Za-z0-9_]+)([?+*]?)/g;\n\n  let match = null,\n    lastIndex = 0,\n    keys = [],\n    result = \"\";\n\n  while ((match = groupRx.exec(pattern)) !== null) {\n    const [_, segment, mod] = match;\n\n    // :foo  [1]      (  )\n    // :foo? [0 - 1]  ( o)\n    // :foo+ [1 - ∞]  (r )\n    // :foo* [0 - ∞]  (ro)\n    const repeat = mod === \"+\" || mod === \"*\";\n    const optional = mod === \"?\" || mod === \"*\";\n    const prefix = optional && pattern[match.index - 1] === \"/\" ? 1 : 0;\n\n    const prev = pattern.substring(lastIndex, match.index - prefix);\n\n    keys.push({ name: segment });\n    lastIndex = groupRx.lastIndex;\n\n    result += escapeRx(prev) + rxForSegment(repeat, optional, prefix);\n  }\n\n  result += escapeRx(pattern.substring(lastIndex));\n  return { keys, regexp: new RegExp(\"^\" + result + \"(?:\\\\/)?$\", \"i\") };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}